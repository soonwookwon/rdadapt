# Calculates inverse modulus \omega^{-1}(b) for the regression function at a point dfaskdjf asdkfj 

invmod = function(b, gam, C, X, mon_ind, sigma = 1){
  
  # gam = (gamma_1,gamma_2)
  # C = (C_1,C_2)
  # X = n*k dimensional matrix
  # sigma can be scalar or n-dimensional vector for sigma(X_i)
  
  C1 = C[1]
  C2 = C[2]
  g1 = gam[1]
  g2 = gam[2]
  
  res =  (b - C1 * Norm(Vplus(X,mon_ind))^g1 - C2 * Norm(Vminus(X,mon_ind))^g2)^2 *  
    (b - C1 * Norm(Vplus(X,mon_ind))^g1 - C2 * Norm(Vminus(X,mon_ind))^g2 > 0)
  
  res = res / sigma^2

  return(sqrt(sum(res)))
}


invmod_RD = function(b,gam,C,Xt,Xc,mon_ind,sigma_t = 1,sigma_c = 1,ret_list = 0){
  
  # gam = (gamma_1,gamma_2)
  # C = (C_1,C_2)
  # Xt = n_t*k dimensional matrix
  # Xc = n_c*k dimensional matrix
  # sigma_t can be scalar or n_t-dimensional vector for sigma(X_{t,i})
  # sigma_c can be scalar or n_c-dimensional vector for sigma(X_{c,i})
  # When ret_list = 0, the function returns the value of delta
  # When ret_list = 1, the function returns the value of b_t, del_t, b_c, del_c
  
  C1 = C[1]
  C2 = C[2]
  g1 = gam[1]
  g2 = gam[2]
  
  ## pull this out
  foc_bt = function(bt){
    tsum = (bt - C1 * Norm(Vplus(Xt,mon_ind))^g1 - C2 * Norm(Vminus(Xt,mon_ind))^g2) *  
      (bt - C1 * Norm(Vplus(Xt,mon_ind))^g1 - C2 * Norm(Vminus(Xt,mon_ind))^g2 > 0) /
      sigma_t^2
    lhs = sum(tsum)
    csum = (b - bt - C2 * Norm(Vplus(Xc,mon_ind))^g2 - C1 * Norm(Vminus(Xc,mon_ind))^g1) *  
      (b - bt - C2 * Norm(Vplus(Xc,mon_ind))^g2 - C1 * Norm(Vminus(Xc,mon_ind))^g1 > 0) /
      sigma_c^2
    rhs = sum(csum)
    return (lhs - rhs)
  }
  
  if(b == 0){
    return(0)
  }else{
    btsol = uniroot(foc_bt,c(0,b), tol = .Machine$double.eps^10)
    bt = btsol$root
    
    dt = invmod(bt,gam,C,Xt,mon_ind,sigma_t)
    dc = invmod(b - bt,gam[2:1],C[2:1],Xc,mon_ind,sigma_c)
    
    if(ret_list == 0){
      res =  sqrt(dt^2 + dc^2)
    }else if(ret_list == 1){
      res = list("bt" = bt, "dt" = dt, "bc" = b - bt, "dc" = dc)
    }
    
    
    return(res)
  }
  
}



# Calculates ordered modulus of continuity: \omega(\delta)

modsol = function(del,gam,C,X,mon_ind,sigma = 1){
  
  maxint = 100
  
  fun = function(b){
    invmod(b,gam,C,X,mon_ind,sigma) - del
  }
  
  solve <- uniroot(fun,c(0,maxint),extendInt="upX", tol = .Machine$double.eps^10)
  return(solve$root)
}

modsol_RD = function(del,gam,C,Xt,Xc,mon_ind,sigma_t,sigma_c,sol_list = 0){
  
  maxint = 100
  
  fun = function(b){
    invmod_RD(b,gam,C,Xt,Xc,mon_ind,sigma_t,sigma_c) - del
  }
  
  solve <- uniroot(fun,c(0,maxint),extendInt="upX", tol = .Machine$double.eps^10)
  bsol <- solve$root
  
  if(sol_list == 0){
    res = bsol
  }else if(sol_list == 1){
    res = invmod_RD(bsol,gam,C,Xt,Xc,mon_ind,sigma_t,sigma_c,ret_list = 1)
  }
  return(res)
}

# For RD design, given J, this function returns
# 1) \om_t(del_adj,C_J,C_j), \om_c(del_adj,C_J,C_j), \om_t(del_adj,C_j,C_J), \om_c(del_adj,C_j,C_J) 
# for j=1,...,J, yielding J*4 dim matrix
# 2) del_jt^L, del_jc^L, del_jt^U, del_jc^U for j=1,...,J, yielding J*4 dim matrix
# 3) adjusted alpha's for adaptive lower and upper CI 
mod_del_cal <- function(gamvec,Cvec,Xt,Xc,kplus_ind,sigma_t,sigma_c){
  
  jlen = length(gamvec)
  if(jlen == 1){   # Minimax case
    
    del_L = qnorm(1-alpha)
    alnewL <- alpha
    alnewU <- alpha
    
  }else{
    
    alnewL = AdjAlpha_RD(gamvec,Cvec,Xt,Xc,kplus_ind,sigma_t,sigma_c,lower=T,rp=alpha)   # adjusted alphas
    alnewU = AdjAlpha_RD(gamvec,Cvec,Xt,Xc,kplus_ind,sigma_t,sigma_c,lower=F,rp=alpha)
    del_L = qnorm(1-alnewL)   # adjusted deltas (corresponds to \delta^{adpt})
    del_U = qnorm(1-alnewU)
    
  }
  
  
  b_mat = matrix(0,jlen,4) # b_tJj, b_cJj, b_tjJ, b_cjJ 
  d_mat = matrix(0,jlen,4) # Corresponding del_jt^L, del_jc^L, del_jt^U, del_jc^U
  
  for(j in 1:jlen){ 
    gampair_j = c(gamvec[j],gamvec[jlen])
    Cpair_j = c(Cvec[j],Cvec[jlen])
    
    res_l = modsol_RD(del_L,gampair_j[2:1],Cpair_j[2:1],Xt,Xc,kplus_ind,sigma_t,sigma_c,
                      sol_list = 1)
    
    if(jlen == 1){   # minimax case
      
      res_u = res_l
      
    }else{
      
      res_u = modsol_RD(del_U,gampair_j,Cpair_j,Xt,Xc,kplus_ind,sigma_t,sigma_c,
                        sol_list = 1)
      
    }
    
    b_mat[j,1:2] = c(res_l$bt,res_l$bc)
    d_mat[j,1:2] = c(res_l$dt,res_l$dc)
    b_mat[j,3:4] = c(res_u$bt,res_u$bc)
    d_mat[j,3:4] = c(res_u$dt,res_u$dc)
  }
  
  res = list(b_mat = b_mat, d_mat = d_mat, alnewL = alnewL, alnewU = alnewU)
  return(res)
  
}


# For RD design, given (C_j,C_J) for some fixed j, this function returns
# 1) \om_t(del_adj,C_J,C_j), \om_c(del_adj,C_J,C_j), \om_t(del_adj,C_j,C_J), \om_c(del_adj,C_j,C_J) 
# yielding 1*4 dim matrix
# 2) del_jt^L, del_jc^L, del_jt^U, del_jc^U yielding 1*4 dim matrix

mod_del_cal_orc <- function(gam,C,maxgam,maxC,Xt,Xc,kplus_ind,sigma_t,sigma_c){
  
  del_L <- qnorm(1-alpha)
  del_U <- qnorm(1-alpha)
  
  b_mat = matrix(0,1,4) # b_tJj, b_cJj, b_tjJ, b_cjJ 
  d_mat = matrix(0,1,4) # Corresponding del_jt^L, del_jc^L, del_jt^U, del_jc^U
  
  gampair_j = c(gam,maxgam)
  Cpair_j = c(C,maxC)
  
  res_l = modsol_RD(del_L,gampair_j[2:1],Cpair_j[2:1],Xt,Xc,kplus_ind,sigma_t,sigma_c,
                    sol_list = 1)
  res_u = modsol_RD(del_U,gampair_j,Cpair_j,Xt,Xc,kplus_ind,sigma_t,sigma_c,
                    sol_list = 1)
  
  
  b_mat[1,1:2] = c(res_l$bt,res_l$bc)
  d_mat[1,1:2] = c(res_l$dt,res_l$dc)
  b_mat[1,3:4] = c(res_u$bt,res_u$bc)
  d_mat[1,3:4] = c(res_u$dt,res_u$dc)
  
  res = list(b_mat = b_mat, d_mat = d_mat)
  return(res)
  
}

# modsol_test = function(del,gam,C,X,mon_ind){
#   
#   maxint = 100
#   
#   fun = function(b){
#     invmod(b,gam,C,X,mon_ind) - del
#   }
#   
#   solve <- uniroot(fun,c(0,maxint),extendInt="upX", tol = .Machine$double.eps^2)
#   return(solve$f.root)
# }




# Calculates between modulus of continuity: \omega_+(\delta)

bmodsol = function(del,gam,C,X,mon_ind,sigma = 1){
  
  res1 = modsol(del,gam,C,X,mon_ind,sigma)
  res2 = modsol(del,gam[c(2,1)],C[c(2,1)],X,mon_ind,sigma)
  
  max(res1,res2)
}




